# Test Data Scenarios Guide

> **Part of the Test Data Generation documentation series:**
>
> - [Architecture](TEST_DATA_ARCHITECTURE.md) - Core architecture, field handlers, boundaries
> - **Scenarios** (this document) - Scenario categories, tool-aware generation, examples
> - [Extension](TEST_DATA_EXTENSION.md) - Adding handlers, debugging, integration

## Overview

This guide covers the different test scenario categories generated by TestDataGenerator, tool category-aware generation, and practical examples of generated test data.

---

## Table of Contents

- [Overview](#overview)
- [1. Scenario Categories](#1-scenario-categories)
  - [Happy Path Scenario](#happy-path-scenario)
  - [Edge Case Scenarios](#edge-case-scenarios)
  - [Boundary Scenarios](#boundary-scenarios)
  - [Error Case Scenario](#error-case-scenario)
- [2. Tool Category-Aware Generation](#2-tool-category-aware-generation)
  - [Category Detection](#category-detection)
  - [Priority System](#priority-system)
- [3. Examples](#3-examples)
  - [Example 1: Simple Calculator Tool](#example-1-simple-calculator-tool)
  - [Example 2: Web Scraper Tool with URL](#example-2-web-scraper-tool-with-url)
  - [Example 3: Nested Object with Arrays](#example-3-nested-object-with-arrays)

---

## 1. Scenario Categories

### Happy Path Scenario

**Purpose**: Test normal usage with realistic, typical input

**Generation**:

```typescript
private static generateHappyPathScenario(tool: Tool): TestScenario {
  const params = this.generateRealisticParams(tool, "typical");

  return {
    name: "Happy Path - Typical Usage",
    description: `Test ${tool.name} with typical, valid inputs`,
    params,
    expectedBehavior: "Should execute successfully and return valid response",
    category: "happy_path",
  };
}
```

**Data Variant**: `"typical"` - realistic, commonly-used values

**Expectations**: Tool should succeed and return meaningful results

### Edge Case Scenarios

**Purpose**: Test with unusual but valid input

**Generated**:

1. **Empty Values**: Minimal but valid input

   ```typescript
   const emptyParams = this.generateRealisticParams(tool, "empty");
   ```

2. **Maximum Values**: Large but valid input

   ```typescript
   const maxParams = this.generateRealisticParams(tool, "maximum");
   ```

3. **Special Characters**: Unicode and special character handling
   ```typescript
   const specialParams = this.generateRealisticParams(tool, "special");
   ```

**Expectations**: Tool should gracefully handle these edge cases

### Boundary Scenarios

**Purpose**: Test exact schema constraints (if defined)

**Generated When**: Tool schema has `minimum`, `maximum`, `minLength`, or `maxLength`

**Examples**:

- Number at minimum value
- Number at maximum value
- String at minimum length
- String at maximum length

**Expectations**: Tool should accept values exactly at boundaries

### Error Case Scenario

**Purpose**: Test error handling with invalid input types

**Generation**:

```typescript
private static generateErrorScenario(tool: Tool): TestScenario {
  const params: Record<string, unknown> = {};

  // Intentionally provide wrong types
  for (const [key, schema] of Object.entries(tool.inputSchema.properties)) {
    const schemaObj = schema as any;

    switch (schemaObj.type) {
      case "string":
        params[key] = 123; // Wrong type (number instead of string)
        break;
      case "number":
      case "integer":
        params[key] = "not_a_number"; // Wrong type (string instead of number)
        break;
      // ... more type mismatches
    }

    break; // Only set one wrong parameter to make error clear
  }

  return {
    name: "Error Case - Invalid Type",
    description: "Test error handling with invalid parameter types",
    params,
    expectedBehavior: "Should return clear error about invalid parameter type",
    category: "error_case",
  };
}
```

**Expectations**: Tool should reject with clear error message (not crash)

---

## 2. Tool Category-Aware Generation

### Category Detection

For tools where field names don't clearly indicate the expected input type, the generator uses tool category hints:

```typescript
static readonly TOOL_CATEGORY_DATA: Record<string, Record<string, string[]>> = {
  calculator: {
    default: ["2+2", "10*5", "100/4", "sqrt(16)", "15-7"],
  },
  search_retrieval: {
    default: [
      "hello world",
      "example query",
      "recent changes",
      "find documents",
    ],
  },
  system_exec: {
    default: ["echo hello", "pwd", "date", "whoami"],
  },
  url_fetcher: {
    default: [
      "https://api.github.com",
      "https://httpbin.org/get",
      "https://jsonplaceholder.typicode.com/posts/1",
    ],
  },
};
```

### Priority System

**Specific Field Names** (highest priority):

- Field name patterns like `url`, `email`, `path`, etc. take precedence over tool category
- Example: A `calculator_tool` with a field named `email_address` will get email-specific values

**Tool Categories** (second priority):

- If field name is generic (like `input`, `params`, `query`), use category-specific values
- Example: A `search_retrieval` tool with a field named `input` gets search queries

**Field Name Fallback** (lowest priority):

- Generic field name with unknown tool category uses standard field-name heuristics
- Example: Generic `calculate` tool with `input` field gets generic "test" value

**Usage**:

```typescript
static generateValueForCategory(
  fieldName: string,
  schema: Record<string, unknown>,
  category: string,
): unknown {
  // Specific field names (url, email, path, etc.) take precedence
  const isSpecificFieldName = this.SPECIFIC_FIELD_PATTERNS.some((pattern) =>
    pattern.test(fieldName),
  );
  if (isSpecificFieldName) {
    return this.generateSingleValue(fieldName, schema);
  }

  // For specific tool categories, use category-specific test values
  const categoryData = this.TOOL_CATEGORY_DATA[category];
  if (categoryData?.default) {
    return categoryData.default[0];
  }

  // Fall back to field-name-based generation
  return this.generateSingleValue(fieldName, schema);
}
```

---

## 3. Examples

### Example 1: Simple Calculator Tool

```typescript
const calculatorTool: Tool = {
  name: "calculate",
  description: "Performs basic math",
  inputSchema: {
    type: "object",
    properties: {
      expression: {
        type: "string",
        description: "Math expression to evaluate",
      },
      decimal_places: {
        type: "number",
        minimum: 0,
        maximum: 10,
        description: "Decimal precision",
      },
    },
    required: ["expression"],
  },
};

// Generated scenarios:
[
  {
    name: "Happy Path - Typical Usage",
    params: { expression: "2+2", decimal_places: 2 },
    category: "happy_path",
  },
  {
    name: "Edge Case - Empty Values",
    params: { expression: "" }, // or "test"
    category: "edge_case",
  },
  {
    name: "Edge Case - Maximum Values",
    params: { expression: "x".repeat(100), decimal_places: 10 },
    category: "edge_case",
  },
  {
    name: "Edge Case - Special Characters",
    params: { expression: "sqrt(-1) + log(0)" },
    category: "edge_case",
  },
  {
    name: "Boundary - decimal_places at minimum",
    params: { expression: "test", decimal_places: 0 },
    category: "boundary",
  },
  {
    name: "Boundary - decimal_places at maximum",
    params: { expression: "test", decimal_places: 10 },
    category: "boundary",
  },
  {
    name: "Error Case - Invalid Type",
    params: { expression: 123 }, // Wrong type: number instead of string
    category: "error_case",
  },
];
```

### Example 2: Web Scraper Tool with URL

```typescript
const scraperTool: Tool = {
  name: "scrape_web",
  description: "Fetches and parses web content",
  inputSchema: {
    type: "object",
    properties: {
      url: {
        type: "string",
        description: "URL to scrape",
        minLength: 10,
        maxLength: 2000,
      },
      timeout_ms: {
        type: "number",
        minimum: 100,
        maximum: 30000,
      },
    },
    required: ["url", "timeout_ms"],
  },
};

// Generated scenarios:
[
  {
    name: "Happy Path - Typical Usage",
    params: {
      url: "https://www.google.com", // From REALISTIC_DATA.urls
      timeout_ms: 5000, // Detected as timeout field
    },
    category: "happy_path",
  },
  {
    name: "Edge Case - Empty Values",
    params: {
      url: "", // Empty variant
      timeout_ms: 100,
    },
    category: "edge_case",
  },
  {
    name: "Edge Case - Maximum Values",
    params: {
      url: "https://very-long-domain-name...", // maxLength variant
      timeout_ms: 30000,
    },
    category: "edge_case",
  },
  {
    name: "Boundary - url at min length",
    params: {
      url: "aaaaaaaaaa", // Exactly 10 'a' characters
      timeout_ms: 5000,
    },
    category: "boundary",
  },
  {
    name: "Boundary - url at max length",
    params: {
      url: "a".repeat(2000), // Exactly 2000 'a' characters
      timeout_ms: 5000,
    },
    category: "boundary",
  },
  {
    name: "Boundary - timeout_ms at minimum",
    params: {
      url: "https://example.com",
      timeout_ms: 100,
    },
    category: "boundary",
  },
  {
    name: "Boundary - timeout_ms at maximum",
    params: {
      url: "https://example.com",
      timeout_ms: 30000,
    },
    category: "boundary",
  },
  {
    name: "Error Case - Invalid Type",
    params: {
      url: 123, // Wrong type
      timeout_ms: 5000,
    },
    category: "error_case",
  },
];
```

### Example 3: Nested Object with Arrays

```typescript
const dataStoreTool: Tool = {
  name: "store_entities",
  description: "Stores data entities",
  inputSchema: {
    type: "object",
    properties: {
      entities: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "Entity UUID"
            },
            name: {
              type: "string",
              minLength: 1,
              maxLength: 100
            },
            metadata: {
              type: "object",
              properties: {
                created_at: { type: "string" },
                tags: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            }
          },
          required: ["id", "name"]
        },
        minItems: 1,
        maxItems: 50
      }
    },
    required: ["entities"]
  }
};

// Happy path scenario:
{
  name: "Happy Path - Typical Usage",
  params: {
    entities: [
      {
        id: "550e8400-e29b-41d4-a716-446655440000", // UUID detected
        name: "Default", // From names pool
        metadata: {
          created_at: "2024-01-01T00:00:00Z", // Timestamp pool
          tags: ["tag1", "tag2", "tag3"] // Context-aware array
        }
      }
    ]
  },
  category: "happy_path"
}

// Boundary scenario (maxItems):
{
  name: "Boundary - entities at maximum",
  params: {
    entities: Array(50).fill({
      id: "550e8400-e29b-41d4-a716-446655440000",
      name: "Item",
      metadata: { tags: [] }
    })
  },
  category: "boundary"
}
```

---

## Summary

The TestDataGenerator creates comprehensive test scenarios across four categories:

| Category   | Purpose                     | Variants/Approach             |
| ---------- | --------------------------- | ----------------------------- |
| Happy Path | Normal usage testing        | `typical` variant             |
| Edge Cases | Unusual but valid input     | `empty`, `maximum`, `special` |
| Boundary   | Schema constraint testing   | Exact min/max values          |
| Error Case | Error handling verification | Type mismatches               |

Tool category awareness ensures even generic fields like `input` or `query` receive appropriate test values based on the tool's purpose (calculator, search, URL fetcher, etc.).

---

## Related Documentation

- [Test Data Architecture](TEST_DATA_ARCHITECTURE.md) - Core architecture, field handlers, boundaries
- [Test Data Extension](TEST_DATA_EXTENSION.md) - Adding handlers, debugging, integration
- [Progressive Complexity Guide](PROGRESSIVE_COMPLEXITY_GUIDE.md) - Multi-level testing strategy
