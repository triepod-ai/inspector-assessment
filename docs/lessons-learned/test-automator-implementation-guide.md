# Test Automator Implementation Guide: Type-Safe Test Generation

**Companion to**: [Type-Safe Testing Patterns](./type-safe-testing-patterns.md)
**Target Audience**: Test Automator Agent Development Team
**Purpose**: Translate lessons from Issue #186 into actionable implementation guidelines

---

## Overview

This guide provides specific implementation recommendations for enhancing the test-automator agent based on patterns discovered during Issue #186 (eliminating 189 `@typescript-eslint/no-explicit-any` violations).

---

## Agent Capability Enhancements

### 1. Type-Safe Mock Generation

**Current Gap**: Mocks likely use `any` or insufficient types
**Enhancement**: Generate fully typed mocks using factory functions

#### Implementation Strategy

```typescript
// Template for mock generation
interface MockGenerationConfig {
  targetType: string; // e.g., "Tool", "AssessmentContext"
  factoryName: string; // e.g., "createMockTool"
  defaultValues: object; // Sensible defaults
  overrideType: string; // Type for override parameter
}

const mockTemplates: Record<string, MockGenerationConfig> = {
  Tool: {
    targetType: "Tool",
    factoryName: "createMockTool",
    defaultValues: {
      name: "test-tool",
      description: "A test tool",
      inputSchema: { type: "object", properties: {} },
    },
    overrideType: "Partial<Tool>",
  },
  AssessmentContext: {
    targetType: "AssessmentContext",
    factoryName: "createMockAssessmentContext",
    defaultValues: {
      serverName: "test-server",
      tools: [],
      config: {},
    },
    overrideType: "Partial<AssessmentContext>",
  },
};
```

#### Generated Test Code Pattern

```typescript
// Agent should generate:
import {
  createMockTool,
  createMockAssessmentContext,
} from "@/test/utils/testUtils";

describe("MyClass", () => {
  let mockContext: AssessmentContext;

  beforeEach(() => {
    // ✅ Type-safe factory usage
    mockContext = createMockAssessmentContext({
      serverName: "test-server",
      tools: [createMockTool({ name: "calculator" })],
    });
  });

  it("should process tools", () => {
    const tool = createMockTool({ name: "test" });
    // Test implementation
  });
});
```

**Benefits**:

- Consistent mock structure across all tests
- Automatic type inference from factory
- Single source of truth for mock defaults
- Easy to update when types change

---

### 2. Private Method Testing Pattern Recognition

**Current Gap**: No standardized approach for private method testing
**Enhancement**: Detect private method tests and generate proper type-safe access

#### Detection Pattern

```typescript
interface PrivateMethodTestSignal {
  // Signals that indicate private method testing:
  indicators: [
    "test internal logic",
    "private method",
    "helper function",
    "implementation detail",
    "unit test for <methodName>",
  ];

  // Anti-patterns to warn about:
  antiPatterns: [
    "(instance as any).",
    "// @ts-ignore",
    "// @ts-expect-error (without valid reason)",
  ];
}
```

#### Code Generation Template

```typescript
/**
 * Template for private method test generation
 */
function generatePrivateMethodTest(config: {
  className: string;
  methodName: string;
  returnType: string;
  testCases: TestCase[];
}): string {
  return `
// Type definition for private method
type ${capitalize(config.methodName)}Fn = ${config.returnType};

describe("${config.className} - ${config.methodName} (private)", () => {
  let instance: ${config.className};
  let ${config.methodName}: ${capitalize(config.methodName)}Fn;

  beforeEach(() => {
    instance = new ${config.className}(mockConfig);
    ${config.methodName} = getPrivateMethod<${config.className}, ${capitalize(config.methodName)}Fn>(
      instance,
      "${config.methodName}"
    );
  });

  ${config.testCases.map((tc) => generateTestCase(tc)).join("\n\n")}
});
`;
}
```

**Example Output**:

```typescript
// Auto-generated by test-automator
type AnalyzeResponsesFn = (tool: Tool, responses: Response[]) => AnalysisResult;

describe("TemporalAssessor - analyzeResponses (private)", () => {
  let assessor: TemporalAssessor;
  let analyzeResponses: AnalyzeResponsesFn;

  beforeEach(() => {
    assessor = new TemporalAssessor(createConfig());
    analyzeResponses = getPrivateMethod<TemporalAssessor, AnalyzeResponsesFn>(
      assessor,
      "analyzeResponses",
    );
  });

  it("detects deviations in responses", () => {
    const tool = createMockTool();
    const responses = [
      /* test data */
    ];

    const result = analyzeResponses(tool, responses);

    expect(result.vulnerable).toBe(true);
    expect(result.deviationCount).toBeGreaterThan(0);
  });
});
```

---

### 3. Type Alias Generation

**Current Gap**: Repetitive type assertions in generated tests
**Enhancement**: Generate type aliases for complex return types

#### Heuristic for Type Alias Generation

```typescript
interface TypeAliasHeuristic {
  generateWhen: {
    // Generate alias if return type meets any of these criteria:
    lengthExceedsChars: 50;
    usedMoreThanTimes: 2;
    hasNestedObjects: true;
    isUnionType: true;
    isFunctionType: true;
  };

  namingStrategy: {
    // How to name the generated type
    patterns: [
      "FunctionName + 'Fn'", // parseSchema → ParseSchemaFn
      "FunctionName + 'Result'", // analyze → AnalyzeResult
      "Descriptive + 'Type'", // testResponse → TestResponseType
    ];
  };
}
```

#### Implementation

```typescript
function generateTypeAliases(testFile: TestFileInfo): string[] {
  const aliases: string[] = [];

  // Analyze return types in test
  for (const method of testFile.methodsCalled) {
    const returnType = inferReturnType(method);

    if (shouldGenerateAlias(returnType)) {
      const aliasName = generateAliasName(method.name, returnType);
      aliases.push(`type ${aliasName} = ${returnType};`);
    }
  }

  return aliases;
}

// Usage in test generation
const typeAliases = generateTypeAliases(testFileInfo);

const testFile = `
${typeAliases.join("\n")}

describe("${className}", () => {
  // Use generated aliases
  ${generateTestCases()}
});
`;
```

**Example Output**:

```typescript
// Auto-generated type aliases
type IsErrorResponseFn = (response: unknown) => boolean;
type ExtractErrorInfoFn = (response: unknown) => {
  code?: number;
  message: string;
};
type AnalysisResult = {
  classification: string;
  shouldPenalize: boolean;
  penaltyAmount: number;
};

describe("ErrorHandlingAssessor", () => {
  // Types used in tests below
});
```

---

### 4. Invalid Input Test Generation

**Current Gap**: No standardized way to test error handling with invalid input
**Enhancement**: Generate properly typed invalid input tests

#### Pattern Recognition

```typescript
interface ErrorHandlingTestPattern {
  testTypes: {
    missingRequired: {
      input: "undefined";
      assertion: "as unknown as RequiredType";
    };
    wrongType: {
      input: "wrong type value";
      assertion: "as unknown as ExpectedType";
    };
    malformed: {
      input: "partially valid";
      assertion: "as PartialType";
    };
    outOfBounds: {
      input: "value outside constraints";
      assertion: "typed normally";
    };
  };
}
```

#### Code Generation

```typescript
function generateInvalidInputTest(config: {
  functionName: string;
  paramType: string;
  invalidValue: unknown;
  expectedBehavior: string;
}): string {
  return `
it("should ${config.expectedBehavior}", () => {
  // Intentionally invalid input for error handling test
  const invalid${config.paramType} = ${JSON.stringify(config.invalidValue)} as unknown as ${config.paramType};

  ${
    config.expectedBehavior.includes("throw")
      ? `expect(() => ${config.functionName}(invalid${config.paramType})).toThrow();`
      : `const result = ${config.functionName}(invalid${config.paramType});
       expect(result).toBeDefined();
       // Verify graceful handling`
  }
});
`;
}
```

**Example Output**:

```typescript
describe("schema validation", () => {
  it("should handle undefined schema gracefully", () => {
    // Intentionally invalid input for error handling test
    const invalidSchema = undefined as unknown as Tool["inputSchema"];

    const result = validateSchema(invalidSchema);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain("Schema is required");
  });

  it("should reject array schema when object expected", () => {
    // Wrong schema type for testing error path
    const wrongSchema = { type: "array" } as unknown as ObjectSchema;

    expect(() => processObjectSchema(wrongSchema)).toThrow(
      "Expected object schema",
    );
  });
});
```

---

### 5. SDK Gap Detection and Extended Types

**Current Gap**: No handling of features beyond SDK types
**Enhancement**: Detect and create extended types for experimental features

#### Detection Strategy

```typescript
interface SDKGapDetector {
  // Detect when code uses properties not in SDK types
  checkForUndocumentedProperties: (code: string) => string[];

  // Generate extended type definitions
  generateExtendedType: (
    baseType: string,
    additionalProps: PropertyInfo[],
  ) => string;

  // Add documentation comments
  documentSDKVersion: (typeName: string, sdkVersion: string) => string;
}
```

#### Implementation

```typescript
function generateExtendedType(config: {
  baseType: string;
  extensionName: string;
  properties: Array<{ name: string; type: string; optional: boolean }>;
  sdkVersion?: string;
}): string {
  const props = config.properties
    .map((p) => `  ${p.name}${p.optional ? "?" : ""}: ${p.type};`)
    .join("\n");

  return `
/**
 * Extended ${config.baseType} type with ${config.extensionName}
 * ${config.sdkVersion ? `Feature added in MCP ${config.sdkVersion}` : "Not yet in SDK types"}
 * TODO: Remove when SDK includes this feature
 */
type ${config.baseType}With${capitalize(config.extensionName)} = ${config.baseType} & {
${props}
};
`;
}
```

**Example Output**:

```typescript
/**
 * Extended Tool type with outputSchema
 * Feature added in MCP 2025-06-18
 * TODO: Remove when SDK includes this feature
 */
type ToolWithOutputSchema = Tool & {
  outputSchema?: Record<string, unknown>;
};

// Usage in tests
it("should handle output schema when present", () => {
  const tool = createMockTool() as ToolWithOutputSchema;
  tool.outputSchema = { type: "object", properties: {} };

  if ((tool as ToolWithOutputSchema).outputSchema) {
    // Process output schema
  }
});
```

---

## Test Generation Workflow

### Phase 1: Analysis

```typescript
interface TestGenerationPhase1 {
  steps: [
    "Analyze target class/function",
    "Identify public vs private methods",
    "Detect error handling requirements",
    "Check for SDK type gaps",
    "Analyze return type complexity",
  ];

  outputs: {
    methodsToTest: MethodInfo[];
    requiredMocks: MockConfig[];
    typeAliases: TypeAliasInfo[];
    extendedTypes: ExtendedTypeInfo[];
  };
}
```

### Phase 2: Template Selection

```typescript
interface TestGenerationPhase2 {
  templates: {
    publicMethod: "standard unit test template";
    privateMethod: "getPrivateMethod template";
    errorHandling: "invalid input template";
    integration: "multi-component template";
  };

  customization: {
    addTypeAliases: boolean;
    useFactoryFunctions: boolean;
    generateExtendedTypes: boolean;
    includeEdgeCases: boolean;
  };
}
```

### Phase 3: Code Generation

```typescript
function generateTest(config: TestGenerationConfig): string {
  // 1. Generate imports
  const imports = generateImports(config);

  // 2. Generate type aliases
  const typeAliases = generateTypeAliases(config);

  // 3. Generate test structure
  const testStructure = generateTestStructure(config);

  // 4. Generate test cases
  const testCases = config.methods.map((m) => generateTestCase(m));

  // 5. Combine into complete test file
  return `
${imports.join("\n")}

${typeAliases.join("\n\n")}

${testStructure}
  ${testCases.join("\n\n")}
});
`;
}
```

---

## Quality Checks

### Pre-Generation Validation

```typescript
interface PreGenerationChecks {
  verify: [
    "All types are importable",
    "Factory functions exist for mocks",
    "Private methods are accessible via getPrivateMethod",
    "No circular type dependencies",
    "Type aliases have unique names",
  ];
}
```

### Post-Generation Validation

```typescript
interface PostGenerationChecks {
  verify: [
    "No `as any` casts",
    "All imports resolve",
    "TypeScript compilation passes",
    "ESLint passes with no warnings",
    "Tests execute successfully",
  ];

  metrics: {
    typeSafety: "100% (no any types)";
    coverage: "All public methods + critical private methods";
    maintainability: "Uses factories and type aliases";
  };
}
```

---

## Configuration Options

### Agent Configuration

```typescript
interface TestAutomatorConfig {
  typeGeneration: {
    // Always generate type aliases for complex types
    generateTypeAliases: true;

    // Use Pick/Omit for partial types
    useUtilityTypes: true;

    // Generate extended types for SDK gaps
    generateExtendedTypes: true;

    // Maximum type complexity before aliasing
    maxTypeComplexity: 50;
  };

  mockGeneration: {
    // Prefer factory functions over manual construction
    useFactories: true;

    // Generate factory if not exists
    generateMissingFactories: true;

    // Include sensible defaults
    includeDefaults: true;
  };

  testStructure: {
    // Separate public and private method tests
    separatePrivateTests: true;

    // Generate edge case tests
    includeEdgeCases: true;

    // Generate error handling tests
    includeErrorTests: true;
  };

  codeQuality: {
    // Fail if any types used
    rejectAnyTypes: true;

    // Require all imports to be typed
    requireTypedImports: true;

    // Enforce consistent naming
    enforceNamingConventions: true;
  };
}
```

---

## Example: Complete Test Generation Flow

### Input: Class to Test

```typescript
// Source: ErrorHandlingAssessor.ts
export class ErrorHandlingAssessor {
  private config: AssessmentConfiguration;

  constructor(config: AssessmentConfiguration) {
    this.config = config;
  }

  public async assess(
    context: AssessmentContext,
  ): Promise<ErrorHandlingResult> {
    // Implementation
  }

  private isErrorResponse(response: unknown): boolean {
    // Implementation
  }

  private extractErrorInfo(response: unknown): {
    code?: number;
    message: string;
  } {
    // Implementation
  }
}
```

### Output: Generated Test

```typescript
/**
 * Auto-generated test suite for ErrorHandlingAssessor
 * Generated by: test-automator v2.0
 * Generation date: 2026-01-17
 * Type safety: 100% (0 any types)
 */

import { ErrorHandlingAssessor } from "../modules/ErrorHandlingAssessor";
import { AssessmentConfiguration } from "@/lib/assessmentTypes";
import {
  getPrivateMethod,
  createMockAssessmentContext,
  createMockAssessmentConfig,
} from "@/test/utils/testUtils";

// ============================================
// Type Definitions
// ============================================

// Return type for isErrorResponse private method
type IsErrorResponseFn = (response: unknown) => boolean;

// Return type for extractErrorInfo private method
type ExtractErrorInfoFn = (response: unknown) => {
  code?: number;
  message: string;
};

// ============================================
// Test Suite
// ============================================

describe("ErrorHandlingAssessor", () => {
  let assessor: ErrorHandlingAssessor;
  let mockConfig: AssessmentConfiguration;

  beforeEach(() => {
    mockConfig = createMockAssessmentConfig();
    assessor = new ErrorHandlingAssessor(mockConfig);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // ============================================
  // Public Method Tests
  // ============================================

  describe("assess", () => {
    it("should assess error handling for all tools", async () => {
      const mockContext = createMockAssessmentContext({
        tools: [
          createMockTool({ name: "tool1" }),
          createMockTool({ name: "tool2" }),
        ],
      });

      const result = await assessor.assess(mockContext);

      expect(result).toBeDefined();
      expect(result.toolsAssessed).toBe(2);
    });

    it("should handle empty tool list", async () => {
      const mockContext = createMockAssessmentContext({ tools: [] });

      const result = await assessor.assess(mockContext);

      expect(result.toolsAssessed).toBe(0);
    });
  });

  // ============================================
  // Private Method Tests
  // ============================================

  describe("isErrorResponse (private)", () => {
    let isErrorResponse: IsErrorResponseFn;

    beforeEach(() => {
      isErrorResponse = getPrivateMethod<
        ErrorHandlingAssessor,
        IsErrorResponseFn
      >(assessor, "isErrorResponse");
    });

    it("should detect MCP error responses", () => {
      const response = {
        error: { code: -32602, message: "Invalid params" },
      };

      expect(isErrorResponse(response)).toBe(true);
    });

    it("should return false for success responses", () => {
      const response = {
        content: [{ type: "text", text: "success" }],
      };

      expect(isErrorResponse(response)).toBe(false);
    });

    it("should handle malformed responses", () => {
      // Intentionally invalid input for error handling test
      const malformed = undefined as unknown as object;

      expect(isErrorResponse(malformed)).toBe(false);
    });
  });

  describe("extractErrorInfo (private)", () => {
    let extractErrorInfo: ExtractErrorInfoFn;

    beforeEach(() => {
      extractErrorInfo = getPrivateMethod<
        ErrorHandlingAssessor,
        ExtractErrorInfoFn
      >(assessor, "extractErrorInfo");
    });

    it("should extract error code and message", () => {
      const response = {
        error: { code: -32602, message: "Invalid params" },
      };

      const info = extractErrorInfo(response);

      expect(info.code).toBe(-32602);
      expect(info.message).toBe("Invalid params");
    });

    it("should handle error without code", () => {
      const response = {
        error: { message: "Something went wrong" },
      };

      const info = extractErrorInfo(response);

      expect(info.code).toBeUndefined();
      expect(info.message).toBe("Something went wrong");
    });
  });
});
```

---

## Maintenance and Evolution

### Version Tracking

```typescript
interface GeneratedTestMetadata {
  generator: "test-automator";
  version: "2.0.0";
  generatedAt: string; // ISO 8601 timestamp
  sourceFile: string; // File tested
  typeSafetyLevel: "100%"; // Percentage without `any`
  patternsUsed: string[]; // ["factories", "type-aliases", "private-method-helpers"]
}
```

### Update Strategy

```typescript
interface TestMaintenanceStrategy {
  whenToRegenerate: [
    "Source class signature changes",
    "New methods added to source",
    "SDK types updated",
    "Test utility patterns updated",
  ];

  migrationPath: {
    // How to migrate old tests to new patterns
    steps: [
      "Parse existing test file",
      "Identify patterns to update",
      "Generate new version",
      "Run side-by-side comparison",
      "Replace if all tests pass",
    ];
  };
}
```

---

## Performance Considerations

### Generation Speed

```typescript
interface PerformanceTargets {
  testGeneration: {
    simpleClass: "< 100ms"; // Class with 5 methods
    complexClass: "< 500ms"; // Class with 20+ methods
    integrationTest: "< 1s"; // Multi-class integration
  };

  analysis: {
    typeInference: "< 50ms per method";
    mockGeneration: "< 20ms per mock";
    templateSelection: "< 10ms";
  };
}
```

### Optimization Strategies

1. **Cache type information**: Don't re-analyze SDK types
2. **Template reuse**: Compile templates once
3. **Parallel generation**: Generate multiple test files concurrently
4. **Incremental updates**: Only regenerate changed parts

---

## Error Handling

### Common Generation Errors

```typescript
interface GenerationErrorHandling {
  errors: {
    "Type not found": {
      recovery: "Import from source or generate placeholder";
      userAction: "Verify import paths";
    };
    "Circular dependency": {
      recovery: "Break cycle with forward reference";
      userAction: "Review type definitions";
    };
    "Private method not accessible": {
      recovery: "Use getPrivateProperty instead of getPrivateMethod";
      userAction: "Verify method exists";
    };
    "Factory function missing": {
      recovery: "Generate inline mock";
      userAction: "Add factory to testUtils.ts";
    };
  };
}
```

---

## Success Metrics

### Key Performance Indicators

```typescript
interface TestGenerationKPIs {
  quality: {
    typeSafety: "100%"; // No `any` types
    eslintCompliance: "100%"; // No warnings
    testCoverage: ">= 80%"; // Code coverage
    falsePositives: "< 1%"; // Incorrect assertions
  };

  efficiency: {
    generationTime: "< 1s per class";
    testsPerSecond: "> 10";
    maintenanceTime: "< 5 min per update";
  };

  maintainability: {
    factoryUsage: "100%"; // All mocks use factories
    typeAliasUsage: "> 90%"; // Complex types aliased
    documentationCoverage: "100%"; // All tests documented
  };
}
```

---

## Integration Points

### With Existing Tools

```typescript
interface ToolIntegration {
  eslint: {
    // Validate generated tests
    rules: ["@typescript-eslint/no-explicit-any"];
    autofix: true;
  };

  prettier: {
    // Format generated code
    format: "automatic";
    config: ".prettierrc";
  };

  jest: {
    // Run generated tests
    command: "npm test";
    watch: false;
  };

  typeScript: {
    // Type check
    command: "tsc --noEmit";
    strict: true;
  };
}
```

---

## Next Steps

1. **Implement pattern templates** in test-automator codebase
2. **Add type inference engine** for automatic type alias generation
3. **Create factory detection** to identify missing mock factories
4. **Build validation pipeline** to ensure 100% type safety
5. **Generate migration scripts** to update existing tests

---

## References

- **Primary Document**: [Type-Safe Testing Patterns](./type-safe-testing-patterns.md)
- **Issue #186**: Type safety in test mocks
- **testUtils.ts**: `/home/bryan/inspector/client/src/test/utils/testUtils.ts`
- **Example Tests**: `/home/bryan/inspector/client/src/services/assessment/__tests__/`

---

**Document Version**: 1.0
**Last Updated**: 2026-01-17
**Target Implementation**: Test Automator Agent v2.0
