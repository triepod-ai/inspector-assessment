/**
 * Chain Exploitation Detection Tests (Issue #93)
 *
 * Validates detection against Challenge #6 ground truth:
 * - vulnerable_chain_executor_tool: Executes chains without validation (MUST detect)
 * - Hardened version: Validation-only, no execution (MUST NOT flag)
 *
 * Success criteria:
 * - 100% recall: All 5 vulnerability categories detected on vulnerable server
 * - 100% precision: 0 false positives on hardened server (same tool names!)
 */

import { SecurityResponseAnalyzer } from "../modules/securityTests/SecurityResponseAnalyzer";
import {
  ChainExecutionTester,
  type ChainExecutionTestResult,
  type CallToolFunction,
} from "../modules/securityTests/ChainExecutionTester";
import type { CompatibilityCallToolResult } from "../modules/securityTests/SecurityPayloadTester";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";

describe("Chain Exploitation Detection - Challenge #6 Validation", () => {
  let analyzer: SecurityResponseAnalyzer;

  beforeEach(() => {
    analyzer = new SecurityResponseAnalyzer();
  });

  /**
   * Helper to create mock response
   */
  function createMockResponse(
    jsonContent: Record<string, unknown>,
  ): CompatibilityCallToolResult {
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(jsonContent),
        },
      ],
    } as CompatibilityCallToolResult;
  }

  describe("SecurityResponseAnalyzer.analyzeChainExploitation()", () => {
    describe("Vulnerable Patterns (MUST detect)", () => {
      it("should detect chain_results in response", () => {
        const response = createMockResponse({
          chain_results: [{ step: 0, tool: "calc", result: { answer: 4 } }],
          steps_executed: 1,
          vulnerabilities_triggered: ["calc_step_0"],
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(true);
        expect(result.chainType).toBe("VULNERABLE_EXECUTION");
      });

      it("should detect output_injection pattern", () => {
        const response = createMockResponse({
          chain_results: [{ step: 1 }],
          steps_executed: 2,
          vulnerabilities_triggered: ["output_injection_step_1"],
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(true);
        expect(result.vulnerabilityCategories).toContain("OUTPUT_INJECTION");
      });

      it("should detect recursive_chain pattern", () => {
        const response = createMockResponse({
          chain_results: [{ tool: "vulnerable_chain_executor" }],
          vulnerabilities_triggered: ["recursive_chain_step_0"],
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(true);
        expect(result.vulnerabilityCategories).toContain("RECURSIVE_CHAIN");
      });

      it("should detect arbitrary tool acceptance", () => {
        const response = createMockResponse({
          chain_results: [{ tool: "MALICIOUS", result: { vulnerable: true } }],
          vulnerabilities_triggered: ["arbitrary_tool_step_0"],
          evidence: "Chain accepted arbitrary tool name",
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(true);
        expect(result.vulnerabilityCategories).toContain(
          "ARBITRARY_TOOL_INVOCATION",
        );
      });

      it("should detect shadowed tool execution", () => {
        const response = createMockResponse({
          chain_results: [
            {
              tool: "calc",
              result: {
                result: "Executed shadowed tool",
                shadowed_definition: "malicious code",
              },
            },
          ],
          vulnerabilities_triggered: ["shadowed_tool_step_0"],
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(true);
        expect(result.vulnerabilityCategories).toContain("TOOL_SHADOWING");
      });

      it("should detect steps_executed with high count (depth bypass)", () => {
        const response = createMockResponse({
          chain_results: Array(15).fill({ tool: "test", result: {} }),
          steps_executed: 15,
          no_depth_limit: true,
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(true);
        expect(result.vulnerabilityCategories).toContain("MISSING_DEPTH_LIMIT");
      });
    });

    describe("Safe Patterns (MUST NOT flag)", () => {
      it("should NOT flag validation-only response", () => {
        const response = createMockResponse({
          result: "Chain stored for admin review",
          validated: true,
          chain_executed: false,
          status: "pending_review",
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(false);
        expect(result.safe).toBe(true);
        expect(result.chainType).toBe("SAFE_VALIDATION");
      });

      it("should NOT flag allowlist rejection", () => {
        const response = createMockResponse({
          result: "Chain rejected",
          reason: "Tool not in allowlist",
          blocked_tools: ["malicious_tool"],
          only_safe_tools_permitted: true,
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(false);
        expect(result.safe).toBe(true);
      });

      it("should NOT flag depth limit enforcement", () => {
        const response = createMockResponse({
          result: "Chain rejected - depth limit enforced",
          max_depth_exceeded: true,
          max_depth: 5,
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(false);
        expect(result.safe).toBe(true);
      });

      it("should NOT flag execution disabled response", () => {
        const response = createMockResponse({
          result: "Chain validated",
          chain_executed: false,
          execution_disabled: true,
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(false);
        expect(result.safe).toBe(true);
      });
    });

    describe("Edge Cases", () => {
      it("should return UNKNOWN for ambiguous response", () => {
        const response = createMockResponse({
          result: "Some generic response",
          status: "ok",
        });

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(false);
        expect(result.safe).toBe(false);
        expect(result.chainType).toBe("UNKNOWN");
      });

      it("should handle empty response", () => {
        const response = createMockResponse({});

        const result = analyzer.analyzeChainExploitation(response);
        expect(result.vulnerable).toBe(false);
        expect(result.chainType).toBe("UNKNOWN");
      });
    });
  });

  describe("ChainExecutionTester", () => {
    let tester: ChainExecutionTester;

    beforeEach(() => {
      tester = new ChainExecutionTester({ verbose: false });
    });

    describe("identifyChainExecutorTools()", () => {
      it("should identify chain executor by name", () => {
        const tools: Tool[] = [
          {
            name: "vulnerable_chain_executor_tool",
            description: "Execute tool chains",
            inputSchema: {
              type: "object",
              properties: { chain: { type: "string" } },
            },
          },
          {
            name: "calculator",
            description: "Math",
            inputSchema: { type: "object", properties: {} },
          },
        ];

        const chainTools = tester.identifyChainExecutorTools(tools);
        expect(chainTools.length).toBe(1);
        expect(chainTools[0].name).toBe("vulnerable_chain_executor_tool");
      });

      it("should identify by parameter names", () => {
        const tools: Tool[] = [
          {
            name: "workflow_runner",
            description: "Run workflows",
            inputSchema: {
              type: "object",
              properties: { steps: { type: "array" } },
            },
          },
        ];

        const chainTools = tester.identifyChainExecutorTools(tools);
        expect(chainTools.length).toBe(1);
      });

      it("should identify by description containing chain keywords", () => {
        const tools: Tool[] = [
          {
            name: "generic_tool",
            description: "Execute a pipeline of operations",
            inputSchema: { type: "object", properties: {} },
          },
        ];

        const chainTools = tester.identifyChainExecutorTools(tools);
        expect(chainTools.length).toBe(1);
      });

      it("should NOT identify non-chain tools", () => {
        const tools: Tool[] = [
          {
            name: "calculator",
            description: "Perform math calculations",
            inputSchema: {
              type: "object",
              properties: { expression: { type: "string" } },
            },
          },
          {
            name: "file_reader",
            description: "Read files from disk",
            inputSchema: {
              type: "object",
              properties: { path: { type: "string" } },
            },
          },
        ];

        const chainTools = tester.identifyChainExecutorTools(tools);
        expect(chainTools.length).toBe(0);
      });
    });

    describe("testChainPayload()", () => {
      it("should detect vulnerability on vulnerable response", async () => {
        const mockCallTool: CallToolFunction = async () => {
          return createMockResponse({
            chain_results: [{ step: 0, tool: "test", result: {} }],
            steps_executed: 1,
            vulnerabilities_triggered: ["test_step_0"],
          });
        };

        const tool: Tool = {
          name: "vulnerable_chain_executor",
          inputSchema: {
            type: "object",
            properties: { chain: { type: "string" } },
          },
        };

        const result = await tester.testChainPayload(
          mockCallTool,
          tool,
          '[{"tool": "test"}]',
        );

        expect(result.vulnerable).toBe(true);
        expect(result.reason).toBe("chain_execution_confirmed");
      });

      it("should NOT detect vulnerability on safe response", async () => {
        const mockCallTool: CallToolFunction = async () => {
          return createMockResponse({
            result: "Chain stored for admin review",
            validated: true,
            chain_executed: false,
          });
        };

        const tool: Tool = {
          name: "vulnerable_chain_executor",
          inputSchema: {
            type: "object",
            properties: { chain: { type: "string" } },
          },
        };

        const result = await tester.testChainPayload(
          mockCallTool,
          tool,
          '[{"tool": "test"}]',
        );

        expect(result.vulnerable).toBe(false);
        expect(result.reason).toBe("validation_only");
      });

      it("should handle test errors gracefully", async () => {
        const mockCallTool: CallToolFunction = async () => {
          throw new Error("Connection refused");
        };

        const tool: Tool = {
          name: "vulnerable_chain_executor",
          inputSchema: {
            type: "object",
            properties: { chain: { type: "string" } },
          },
        };

        const result = await tester.testChainPayload(
          mockCallTool,
          tool,
          '[{"tool": "test"}]',
        );

        expect(result.vulnerable).toBe(false);
        expect(result.reason).toBe("test_error");
        expect(result.error).toContain("Connection refused");
      });
    });

    describe("runChainExploitationTests()", () => {
      it("should detect vulnerabilities on vulnerable server", async () => {
        const mockCallTool: CallToolFunction = async () => {
          return createMockResponse({
            chain_results: [{ step: 0, tool: "test", result: {} }],
            steps_executed: 1,
            vulnerabilities_triggered: ["test_step_0"],
            vulnerable: true,
          });
        };

        const tool: Tool = {
          name: "vulnerable_chain_executor",
          inputSchema: {
            type: "object",
            properties: { chain: { type: "string" } },
          },
        };

        const results = await tester.runChainExploitationTests(
          mockCallTool,
          tool,
        );
        const summary = tester.summarizeResults(results);

        expect(summary.vulnerable).toBeGreaterThan(0);
        expect(summary.vulnerableTests.length).toBeGreaterThan(0);
      });

      it("should NOT detect vulnerabilities on hardened server", async () => {
        const mockCallTool: CallToolFunction = async () => {
          return createMockResponse({
            result: "Chain stored for admin review",
            validated: true,
            chain_executed: false,
            status: "pending_review",
          });
        };

        const tool: Tool = {
          name: "vulnerable_chain_executor",
          inputSchema: {
            type: "object",
            properties: { chain: { type: "string" } },
          },
        };

        const results = await tester.runChainExploitationTests(
          mockCallTool,
          tool,
        );
        const summary = tester.summarizeResults(results);

        expect(summary.vulnerable).toBe(0);
      });
    });

    describe("summarizeResults()", () => {
      it("should correctly summarize mixed results", () => {
        const results = new Map<string, ChainExecutionTestResult>();
        results.set("test1", {
          vulnerable: true,
          reason: "chain_execution_confirmed",
          vulnerabilityCategories: ["OUTPUT_INJECTION"],
        });
        results.set("test2", {
          vulnerable: false,
          reason: "validation_only",
        });
        results.set("test3", {
          vulnerable: false,
          reason: "test_error",
          error: "Connection failed",
        });

        const summary = tester.summarizeResults(results);

        expect(summary.total).toBe(3);
        expect(summary.vulnerable).toBe(1);
        expect(summary.safe).toBe(1);
        expect(summary.errors).toBe(1);
        expect(summary.vulnerableTests).toContain("test1");
        expect(summary.vulnerabilityCategories).toContain("OUTPUT_INJECTION");
      });
    });
  });
});
