/**
 * Dependency Vulnerability Assessor
 * Detects npm/yarn/pnpm dependency vulnerabilities via package manager audits
 *
 * Implements Issue #193: Add npm/yarn dependency vulnerability detection module
 *
 * Checks:
 * - Detects package manager from lock file (package-lock.json, yarn.lock, pnpm-lock.yaml)
 * - Runs audit command: npm audit --json / yarn audit --json / pnpm audit --json
 * - Parses vulnerability counts by severity
 * - Calculates score penalty based on severity weights
 *
 * Severity Scoring (from Issue #193):
 * - critical: -10 points
 * - high: -5 points
 * - moderate: -2 points
 * - low: -1 point
 *
 * Context Requirements:
 * - sourceCodePath: Required - directory to run audit in
 *
 * Note: This module requires shell execution and is opt-in only.
 */

import { exec as execCallback } from "child_process";
import { promisify } from "util";
import * as path from "path";
import * as fs from "fs";

import { BaseAssessor } from "./BaseAssessor";
import { AssessmentContext } from "../AssessmentOrchestrator";
import type {
  DependencyVulnerabilityAssessment,
  VulnerabilityCounts,
  DependencyVulnerability,
  PackageManager,
  LockFileType,
  AuditExecutionInfo,
  NpmAuditOutput,
  YarnAuditEntry,
  PnpmAuditOutput,
  VulnerabilitySeverity,
  AssessmentStatus,
} from "@/lib/assessmentTypes";

const exec = promisify(execCallback);

// Severity scoring weights from Issue #193
const SEVERITY_WEIGHTS: Record<VulnerabilitySeverity, number> = {
  critical: -10,
  high: -5,
  moderate: -2,
  low: -1,
};

// Audit timeout (30 seconds as suggested in issue)
const AUDIT_TIMEOUT_MS = 30000;

// Maximum buffer size for audit output (10MB)
const MAX_BUFFER_SIZE = 10 * 1024 * 1024;

/**
 * Lock file to package manager mapping
 */
const LOCK_FILE_MAP: Record<
  string,
  { manager: PackageManager; lockFileType: LockFileType }
> = {
  "package-lock.json": { manager: "npm", lockFileType: "package-lock.json" },
  "yarn.lock": { manager: "yarn", lockFileType: "yarn.lock" },
  "pnpm-lock.yaml": { manager: "pnpm", lockFileType: "pnpm-lock.yaml" },
};

/**
 * Empty vulnerability counts
 */
const EMPTY_COUNTS: VulnerabilityCounts = {
  critical: 0,
  high: 0,
  moderate: 0,
  low: 0,
};

export class DependencyVulnerabilityAssessor extends BaseAssessor<DependencyVulnerabilityAssessment> {
  /**
   * Run dependency vulnerability assessment
   */
  async assess(
    context: AssessmentContext,
  ): Promise<DependencyVulnerabilityAssessment> {
    this.logger.info("Starting dependency vulnerability assessment");
    this.testCount = 0;

    // Check if source code path is provided
    if (!context.sourceCodePath) {
      this.logger.info("No source code path provided, skipping assessment");
      return this.createSkippedResult(
        "No source code path provided. Use --source flag to enable dependency audit.",
      );
    }

    // Detect package manager from lock file
    const { manager, lockFileType } = this.detectPackageManager(
      context.sourceCodePath,
    );
    if (manager === "unknown") {
      this.logger.info("No lock file detected, skipping assessment");
      return this.createSkippedResult(
        "No package-lock.json, yarn.lock, or pnpm-lock.yaml found. Cannot run audit.",
      );
    }

    this.logger.info(`Detected package manager: ${manager} (${lockFileType})`);
    this.testCount++; // Audit execution counts as 1 test

    // Run the audit command
    const auditResult = await this.runAudit(
      context.sourceCodePath,
      manager,
      lockFileType,
    );

    if (!auditResult.auditInfo.auditCompleted) {
      this.logger.warn(`Audit failed: ${auditResult.auditInfo.auditError}`);
      return this.createErrorResult(auditResult.auditInfo);
    }

    // Parse audit results
    const { vulnerabilities, findings, totalAdvisories } =
      this.parseAuditResults(auditResult.rawOutput, manager);

    // Calculate score penalty
    const scorePenalty = this.calculateScorePenalty(vulnerabilities);

    // Determine status
    const status = this.determineVulnerabilityStatus(vulnerabilities);

    // Generate explanation and recommendations
    const explanation = this.generateExplanation(
      vulnerabilities,
      totalAdvisories,
      manager,
    );
    const recommendations = this.generateRecommendations(findings, manager);

    this.logger.info(
      `Assessment complete: ${totalAdvisories} advisories found, score penalty: ${scorePenalty}`,
    );

    return {
      hasPackageManager: true,
      auditInfo: auditResult.auditInfo,
      vulnerabilities,
      totalAdvisories,
      findings,
      scorePenalty,
      status,
      explanation,
      recommendations,
    };
  }

  /**
   * Detect package manager from lock file in the source directory
   */
  private detectPackageManager(sourceCodePath: string): {
    manager: PackageManager;
    lockFileType: LockFileType;
  } {
    for (const [lockFile, info] of Object.entries(LOCK_FILE_MAP)) {
      const lockPath = path.join(sourceCodePath, lockFile);
      if (fs.existsSync(lockPath)) {
        return info;
      }
    }
    return { manager: "unknown", lockFileType: "none" };
  }

  /**
   * Run the package manager audit command
   */
  private async runAudit(
    sourceCodePath: string,
    packageManager: PackageManager,
    lockFileType: LockFileType,
  ): Promise<{ auditInfo: AuditExecutionInfo; rawOutput?: string }> {
    const command = this.getAuditCommand(packageManager);
    const startTime = Date.now();

    try {
      // npm/yarn/pnpm audit exit non-zero when vulnerabilities found
      // We need to capture stdout even on error
      const { stdout } = await exec(command, {
        cwd: sourceCodePath,
        timeout: AUDIT_TIMEOUT_MS,
        maxBuffer: MAX_BUFFER_SIZE,
      });

      return {
        auditInfo: {
          packageManager,
          lockFilePresent: true,
          lockFileType,
          auditCommand: command,
          executionTimeMs: Date.now() - startTime,
          auditCompleted: true,
        },
        rawOutput: stdout,
      };
    } catch (error: unknown) {
      const execError = error as {
        stdout?: string;
        stderr?: string;
        code?: number;
        killed?: boolean;
        signal?: string;
      };

      // Check if timeout killed the process
      if (execError.killed || execError.signal === "SIGTERM") {
        return {
          auditInfo: {
            packageManager,
            lockFilePresent: true,
            lockFileType,
            auditCommand: command,
            executionTimeMs: Date.now() - startTime,
            auditCompleted: false,
            auditError: `Audit timed out after ${AUDIT_TIMEOUT_MS}ms`,
          },
        };
      }

      // npm/yarn/pnpm audit exits with code 1 when vulnerabilities found
      // Check if we still got output
      if (execError.stdout) {
        return {
          auditInfo: {
            packageManager,
            lockFilePresent: true,
            lockFileType,
            auditCommand: command,
            executionTimeMs: Date.now() - startTime,
            auditCompleted: true,
          },
          rawOutput: execError.stdout,
        };
      }

      // Actual error - no output
      return {
        auditInfo: {
          packageManager,
          lockFilePresent: true,
          lockFileType,
          auditCommand: command,
          executionTimeMs: Date.now() - startTime,
          auditCompleted: false,
          auditError: execError.stderr || String(error),
        },
      };
    }
  }

  /**
   * Get the audit command for a package manager
   */
  private getAuditCommand(packageManager: PackageManager): string {
    switch (packageManager) {
      case "npm":
        return "npm audit --json";
      case "yarn":
        return "yarn audit --json";
      case "pnpm":
        return "pnpm audit --json";
      default:
        return "npm audit --json";
    }
  }

  /**
   * Parse audit results from JSON output
   */
  private parseAuditResults(
    rawOutput: string | undefined,
    packageManager: PackageManager,
  ): {
    vulnerabilities: VulnerabilityCounts;
    findings: DependencyVulnerability[];
    totalAdvisories: number;
  } {
    if (!rawOutput) {
      return {
        vulnerabilities: { ...EMPTY_COUNTS },
        findings: [],
        totalAdvisories: 0,
      };
    }

    try {
      switch (packageManager) {
        case "npm":
          return this.parseNpmAudit(rawOutput);
        case "yarn":
          return this.parseYarnAudit(rawOutput);
        case "pnpm":
          return this.parsePnpmAudit(rawOutput);
        default:
          return this.parseNpmAudit(rawOutput);
      }
    } catch (error) {
      this.logger.error("Failed to parse audit output", { error });
      return {
        vulnerabilities: { ...EMPTY_COUNTS },
        findings: [],
        totalAdvisories: 0,
      };
    }
  }

  /**
   * Parse npm audit --json output
   */
  private parseNpmAudit(rawOutput: string): {
    vulnerabilities: VulnerabilityCounts;
    findings: DependencyVulnerability[];
    totalAdvisories: number;
  } {
    const auditData = JSON.parse(rawOutput) as NpmAuditOutput;
    const vulnerabilities: VulnerabilityCounts = { ...EMPTY_COUNTS };
    const findings: DependencyVulnerability[] = [];

    if (auditData.vulnerabilities) {
      for (const [pkgName, vuln] of Object.entries(auditData.vulnerabilities)) {
        const severity = this.normalizeSeverity(vuln.severity);
        vulnerabilities[severity]++;

        // Extract advisory info from via field
        let advisory = "";
        let cve: string | undefined;
        if (Array.isArray(vuln.via)) {
          const advisories: string[] = [];
          for (const v of vuln.via) {
            if (typeof v === "string") {
              advisories.push(v);
            } else if (v && typeof v === "object") {
              if (v.title) advisories.push(v.title);
              // CVE not directly available in npm audit via, would need to lookup
            }
          }
          advisory = advisories.join(", ");
        } else {
          advisory = String(vuln.via);
        }

        // Determine if fix is available
        const fixAvailable =
          typeof vuln.fixAvailable === "boolean"
            ? vuln.fixAvailable
            : vuln.fixAvailable !== undefined;

        // Build dependency path
        const dependencyPath = vuln.nodes || [pkgName];

        findings.push({
          packageName: pkgName,
          version: "unknown", // npm audit doesn't provide version in vulnerabilities object
          severity,
          advisory,
          cve,
          fixAvailable,
          dependencyPath,
          isDirect: dependencyPath.length === 1,
        });
      }
    }

    // If metadata is available, prefer those counts
    if (auditData.metadata?.vulnerabilities) {
      const meta = auditData.metadata.vulnerabilities;
      vulnerabilities.critical = meta.critical ?? vulnerabilities.critical;
      vulnerabilities.high = meta.high ?? vulnerabilities.high;
      vulnerabilities.moderate = meta.moderate ?? vulnerabilities.moderate;
      vulnerabilities.low = meta.low ?? vulnerabilities.low;
    }

    const totalAdvisories =
      vulnerabilities.critical +
      vulnerabilities.high +
      vulnerabilities.moderate +
      vulnerabilities.low;

    return { vulnerabilities, findings, totalAdvisories };
  }

  /**
   * Parse yarn audit --json output (newline-delimited JSON)
   */
  private parseYarnAudit(rawOutput: string): {
    vulnerabilities: VulnerabilityCounts;
    findings: DependencyVulnerability[];
    totalAdvisories: number;
  } {
    const vulnerabilities: VulnerabilityCounts = { ...EMPTY_COUNTS };
    const findings: DependencyVulnerability[] = [];

    // Yarn emits newline-delimited JSON objects
    const lines = rawOutput.trim().split("\n");
    for (const line of lines) {
      if (!line.trim()) continue;

      try {
        const entry = JSON.parse(line) as YarnAuditEntry;

        if (entry.type === "auditAdvisory" && "resolution" in entry.data) {
          const data = entry.data as {
            resolution: { id: number; path: string; dev: boolean };
            advisory: {
              module_name: string;
              severity: string;
              title: string;
              cves?: string[];
              patched_versions?: string;
            };
          };

          const severity = this.normalizeSeverity(data.advisory.severity);
          vulnerabilities[severity]++;

          findings.push({
            packageName: data.advisory.module_name,
            version: "unknown",
            severity,
            advisory: data.advisory.title,
            cve: data.advisory.cves?.[0],
            fixedIn: data.advisory.patched_versions,
            fixAvailable: Boolean(data.advisory.patched_versions),
            dependencyPath: data.resolution.path.split(">"),
            isDirect: !data.resolution.path.includes(">"),
          });
        } else if (
          entry.type === "auditSummary" &&
          "vulnerabilities" in entry.data
        ) {
          // Override with summary counts if available
          const data = entry.data as {
            vulnerabilities: {
              info: number;
              low: number;
              moderate: number;
              high: number;
              critical: number;
            };
          };
          vulnerabilities.critical = data.vulnerabilities.critical;
          vulnerabilities.high = data.vulnerabilities.high;
          vulnerabilities.moderate = data.vulnerabilities.moderate;
          vulnerabilities.low = data.vulnerabilities.low;
        }
      } catch {
        // Skip malformed lines
        this.logger.debug("Skipping malformed yarn audit line", {
          line: line.substring(0, 100),
        });
        continue;
      }
    }

    const totalAdvisories =
      vulnerabilities.critical +
      vulnerabilities.high +
      vulnerabilities.moderate +
      vulnerabilities.low;

    return { vulnerabilities, findings, totalAdvisories };
  }

  /**
   * Parse pnpm audit --json output
   */
  private parsePnpmAudit(rawOutput: string): {
    vulnerabilities: VulnerabilityCounts;
    findings: DependencyVulnerability[];
    totalAdvisories: number;
  } {
    const auditData = JSON.parse(rawOutput) as PnpmAuditOutput;
    const vulnerabilities: VulnerabilityCounts = { ...EMPTY_COUNTS };
    const findings: DependencyVulnerability[] = [];

    if (auditData.advisories) {
      for (const [, advisory] of Object.entries(auditData.advisories)) {
        const severity = this.normalizeSeverity(advisory.severity);
        vulnerabilities[severity]++;

        const finding: DependencyVulnerability = {
          packageName: advisory.module_name,
          version: advisory.findings?.[0]?.version || "unknown",
          severity,
          advisory: advisory.title,
          cve: advisory.cves?.[0],
          fixedIn: advisory.patched_versions,
          fixAvailable: Boolean(advisory.patched_versions),
          dependencyPath: advisory.findings?.[0]?.paths?.[0]?.split(">") || [
            advisory.module_name,
          ],
          isDirect: !advisory.findings?.[0]?.paths?.[0]?.includes(">"),
        };
        findings.push(finding);
      }
    }

    // Prefer metadata counts if available
    if (auditData.metadata?.vulnerabilities) {
      const meta = auditData.metadata.vulnerabilities;
      vulnerabilities.critical = meta.critical ?? vulnerabilities.critical;
      vulnerabilities.high = meta.high ?? vulnerabilities.high;
      vulnerabilities.moderate = meta.moderate ?? vulnerabilities.moderate;
      vulnerabilities.low = meta.low ?? vulnerabilities.low;
    }

    const totalAdvisories =
      vulnerabilities.critical +
      vulnerabilities.high +
      vulnerabilities.moderate +
      vulnerabilities.low;

    return { vulnerabilities, findings, totalAdvisories };
  }

  /**
   * Normalize severity string to VulnerabilitySeverity type
   */
  private normalizeSeverity(severity: string): VulnerabilitySeverity {
    const normalized = severity.toLowerCase();
    if (normalized === "critical") return "critical";
    if (normalized === "high") return "high";
    if (normalized === "moderate" || normalized === "medium") return "moderate";
    return "low";
  }

  /**
   * Calculate score penalty based on vulnerability counts
   */
  private calculateScorePenalty(vulns: VulnerabilityCounts): number {
    const penalty =
      vulns.critical * SEVERITY_WEIGHTS.critical +
      vulns.high * SEVERITY_WEIGHTS.high +
      vulns.moderate * SEVERITY_WEIGHTS.moderate +
      vulns.low * SEVERITY_WEIGHTS.low;
    // Convert -0 to 0 for consistent comparison
    return penalty || 0;
  }

  /**
   * Determine assessment status based on vulnerability counts
   */
  private determineVulnerabilityStatus(
    vulns: VulnerabilityCounts,
  ): AssessmentStatus {
    if (vulns.critical > 0) return "FAIL";
    if (vulns.high > 0) return "NEED_MORE_INFO";
    if (vulns.moderate > 0) return "NEED_MORE_INFO";
    return "PASS";
  }

  /**
   * Generate human-readable explanation
   */
  private generateExplanation(
    vulns: VulnerabilityCounts,
    total: number,
    manager: PackageManager,
  ): string {
    if (total === 0) {
      return `No dependency vulnerabilities found via ${manager} audit.`;
    }

    const parts: string[] = [];
    if (vulns.critical > 0) parts.push(`${vulns.critical} critical`);
    if (vulns.high > 0) parts.push(`${vulns.high} high`);
    if (vulns.moderate > 0) parts.push(`${vulns.moderate} moderate`);
    if (vulns.low > 0) parts.push(`${vulns.low} low`);

    const penalty = this.calculateScorePenalty(vulns);
    return `Found ${total} dependency vulnerabilities: ${parts.join(", ")}. Score penalty: ${penalty} points.`;
  }

  /**
   * Generate actionable recommendations
   */
  private generateRecommendations(
    findings: DependencyVulnerability[],
    manager: PackageManager,
  ): string[] {
    const recommendations: string[] = [];

    // Count fixable vulnerabilities
    const fixable = findings.filter((f) => f.fixAvailable).length;
    if (fixable > 0) {
      const fixCmd =
        manager === "npm"
          ? "npm audit fix"
          : manager === "yarn"
            ? "yarn audit fix"
            : "pnpm audit --fix";
      recommendations.push(
        `Run '${fixCmd}' to automatically fix ${fixable} vulnerabilities`,
      );
    }

    // Add specific recommendations for critical/high vulnerabilities
    const critical = findings.filter((f) => f.severity === "critical");
    const high = findings.filter((f) => f.severity === "high");

    for (const vuln of critical.slice(0, 3)) {
      recommendations.push(
        `CRITICAL: Review ${vuln.packageName} - ${vuln.advisory}${vuln.fixedIn ? ` (fix: ${vuln.fixedIn})` : ""}`,
      );
    }

    for (const vuln of high.slice(0, 3)) {
      recommendations.push(
        `HIGH: Review ${vuln.packageName} - ${vuln.advisory}${vuln.fixedIn ? ` (fix: ${vuln.fixedIn})` : ""}`,
      );
    }

    if (recommendations.length === 0) {
      recommendations.push(
        "No critical action required - only low severity vulnerabilities found",
      );
    }

    return recommendations;
  }

  /**
   * Create a skipped result with explanation
   */
  private createSkippedResult(
    reason: string,
  ): DependencyVulnerabilityAssessment {
    return {
      hasPackageManager: false,
      auditInfo: {
        packageManager: "unknown",
        lockFilePresent: false,
        lockFileType: "none",
        auditCommand: "",
        executionTimeMs: 0,
        auditCompleted: false,
      },
      vulnerabilities: { ...EMPTY_COUNTS },
      totalAdvisories: 0,
      findings: [],
      scorePenalty: 0,
      status: "NEED_MORE_INFO",
      explanation: `Dependency audit skipped: ${reason}`,
      recommendations: [
        "Provide --source <path> to enable dependency vulnerability scanning",
        "Ensure package-lock.json, yarn.lock, or pnpm-lock.yaml exists in the source directory",
      ],
      skipped: true,
      skipReason: reason,
    };
  }

  /**
   * Create an error result when audit fails
   */
  private createErrorResult(
    auditInfo: AuditExecutionInfo,
  ): DependencyVulnerabilityAssessment {
    return {
      hasPackageManager: true,
      auditInfo,
      vulnerabilities: { ...EMPTY_COUNTS },
      totalAdvisories: 0,
      findings: [],
      scorePenalty: 0,
      status: "NEED_MORE_INFO",
      explanation: `Dependency audit failed: ${auditInfo.auditError || "Unknown error"}`,
      recommendations: [
        `Check that ${auditInfo.packageManager} is installed and accessible`,
        "Verify the lock file is valid and not corrupted",
        "Try running the audit command manually to diagnose issues",
        `Manual command: ${auditInfo.auditCommand}`,
      ],
      skipped: false,
    };
  }
}
