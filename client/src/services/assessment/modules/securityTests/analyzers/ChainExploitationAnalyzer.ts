/**
 * Chain Exploitation Analyzer (Issue #93, Challenge #6)
 * Detects multi-tool chained exploitation attacks
 *
 * Extracted from SecurityResponseAnalyzer.ts for modularity (Issue #179)
 */

import { CompatibilityCallToolResult } from "@modelcontextprotocol/sdk/types.js";
import {
  CHAIN_EXPLOIT_VULNERABLE_PATTERNS,
  CHAIN_EXPLOIT_SAFE_PATTERNS,
  CHAIN_VULNERABLE_THRESHOLD,
  CHAIN_SAFE_THRESHOLD,
  detectVulnerabilityCategories,
} from "../SecurityPatternLibrary";
import { SafeResponseDetector } from "../SafeResponseDetector";

/**
 * Chain execution type classification (Issue #93, Challenge #6)
 */
export type ChainExecutionType =
  | "VULNERABLE_EXECUTION" // Chain actually executes tools with vulnerabilities
  | "SAFE_VALIDATION" // Chain validated but not executed (hardened)
  | "PARTIAL" // Mixed signals in response
  | "UNKNOWN"; // Cannot determine chain behavior

/**
 * Chain vulnerability categories (Issue #93, Challenge #6)
 */
export type ChainVulnerabilityCategory =
  | "OUTPUT_INJECTION" // {{output}} template injection between steps
  | "RECURSIVE_CHAIN" // Self-referential chain execution (DoS)
  | "ARBITRARY_TOOL_INVOCATION" // No tool allowlist validation
  | "TOOL_SHADOWING" // Executes shadowed/poisoned tool definitions
  | "MISSING_DEPTH_LIMIT" // No/bypassable chain depth limits
  | "STATE_POISONING"; // Steps modify shared state affecting later steps

/**
 * Result of chain exploitation analysis (Issue #93, Challenge #6)
 * Detects multi-tool chained exploitation attacks
 */
export interface ChainExploitationAnalysis {
  vulnerable: boolean;
  safe: boolean;
  chainType: ChainExecutionType;
  vulnerabilityCategories: ChainVulnerabilityCategory[];
  evidence: {
    vulnerablePatterns: string[];
    safePatterns: string[];
    vulnerableScore: number;
    safeScore: number;
  };
}

/**
 * Analyzes responses for chain exploitation vulnerabilities
 *
 * Detects multi-tool chained exploitation attacks including:
 * - Arbitrary tool invocation without allowlist
 * - Output injection via {{output}} template substitution
 * - Recursive/circular chain execution (DoS potential)
 * - State poisoning between chain steps
 * - Tool shadowing in chains
 * - Missing depth/size limits
 */
export class ChainExploitationAnalyzer {
  private safeDetector: SafeResponseDetector;

  constructor() {
    this.safeDetector = new SafeResponseDetector();
  }

  /**
   * Analyze response for chain exploitation vulnerabilities (Issue #93, Challenge #6)
   *
   * @param response The tool response to analyze
   * @returns Analysis result with vulnerability status and evidence
   */
  analyze(response: CompatibilityCallToolResult): ChainExploitationAnalysis {
    const responseText = this.safeDetector.extractResponseContent(response);

    let vulnerableScore = 0;
    let safeScore = 0;
    const matchedVulnPatterns: string[] = [];
    const matchedSafePatterns: string[] = [];

    // Check vulnerable patterns
    for (const patternDef of CHAIN_EXPLOIT_VULNERABLE_PATTERNS) {
      if (patternDef.pattern.test(responseText)) {
        vulnerableScore += patternDef.weight;
        matchedVulnPatterns.push(patternDef.description);
      }
    }

    // Check safe patterns
    for (const patternDef of CHAIN_EXPLOIT_SAFE_PATTERNS) {
      if (patternDef.pattern.test(responseText)) {
        safeScore += patternDef.weight;
        matchedSafePatterns.push(patternDef.description);
      }
    }

    // Determine chain execution type using documented thresholds
    let chainType: ChainExecutionType = "UNKNOWN";
    if (
      vulnerableScore > CHAIN_VULNERABLE_THRESHOLD &&
      vulnerableScore > safeScore
    ) {
      chainType = "VULNERABLE_EXECUTION";
    } else if (
      safeScore > CHAIN_SAFE_THRESHOLD &&
      safeScore > vulnerableScore
    ) {
      chainType = "SAFE_VALIDATION";
    } else if (vulnerableScore > 0 || safeScore > 0) {
      chainType = "PARTIAL";
    }

    // Detect specific vulnerability categories using centralized pattern library
    const detectedCategories = detectVulnerabilityCategories(responseText);
    const vulnerabilityCategories =
      detectedCategories as ChainVulnerabilityCategory[];

    return {
      vulnerable:
        vulnerableScore > CHAIN_VULNERABLE_THRESHOLD &&
        vulnerableScore > safeScore,
      safe: safeScore > CHAIN_SAFE_THRESHOLD && safeScore > vulnerableScore,
      chainType,
      vulnerabilityCategories,
      evidence: {
        vulnerablePatterns: matchedVulnPatterns,
        safePatterns: matchedSafePatterns,
        vulnerableScore,
        safeScore,
      },
    };
  }
}
