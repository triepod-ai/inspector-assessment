/**
 * Diff Report Formatter
 * Generates markdown reports for assessment comparisons.
 */

import type { AssessmentDiff, ChangeDirection } from "../assessmentDiffer";

/**
 * Format an assessment diff as a markdown report
 */
export function formatDiffAsMarkdown(diff: AssessmentDiff): string {
  const lines: string[] = [];

  // Header
  lines.push("# Assessment Comparison Report");
  lines.push("");
  lines.push(`**Server:** ${diff.serverName}`);
  lines.push(
    `**Baseline:** ${diff.baseline.version || "N/A"} (${formatDate(diff.baseline.date)})`,
  );
  lines.push(
    `**Current:** ${diff.current.version || "N/A"} (${formatDate(diff.current.date)})`,
  );
  lines.push(
    `**Overall Change:** ${formatChangeIcon(diff.summary.overallChange)} ${capitalize(diff.summary.overallChange)}`,
  );
  lines.push("");

  // Summary Table
  lines.push("## Summary");
  lines.push("");
  lines.push("| Metric | Baseline | Current | Change |");
  lines.push("|--------|----------|---------|--------|");
  lines.push(
    `| Overall Status | ${diff.summary.baselineStatus} | ${diff.summary.currentStatus} | ${formatStatusChange(diff.summary.baselineStatus, diff.summary.currentStatus)} |`,
  );
  lines.push(
    `| Security Issues | ${diff.securityDelta.baselineCount} | ${diff.securityDelta.currentCount} | ${formatNumericChange(-diff.securityDelta.netChange)} |`,
  );
  lines.push(
    `| Working Tools | ${diff.functionalityDelta.baselineWorking} | ${diff.functionalityDelta.currentWorking} | ${formatNumericChange(diff.functionalityDelta.netChange)} |`,
  );
  lines.push(`| Modules Improved | - | - | ${diff.summary.modulesImproved} |`);
  lines.push(
    `| Modules Regressed | - | - | ${diff.summary.modulesRegressed} |`,
  );
  lines.push("");

  // Security Changes
  if (
    diff.securityDelta.newVulnerabilities.length > 0 ||
    diff.securityDelta.fixedVulnerabilities.length > 0
  ) {
    lines.push("## Security Changes");
    lines.push("");

    if (diff.securityDelta.fixedVulnerabilities.length > 0) {
      for (const vuln of diff.securityDelta.fixedVulnerabilities) {
        lines.push(`- ✅ **Fixed:** ${vuln}`);
      }
    }

    if (diff.securityDelta.newVulnerabilities.length > 0) {
      for (const vuln of diff.securityDelta.newVulnerabilities) {
        lines.push(`- ⚠️ **New:** ${vuln}`);
      }
    }
    lines.push("");
  }

  // Functionality Changes
  if (
    diff.functionalityDelta.newBrokenTools.length > 0 ||
    diff.functionalityDelta.fixedTools.length > 0
  ) {
    lines.push("## Functionality Changes");
    lines.push("");

    if (diff.functionalityDelta.fixedTools.length > 0) {
      for (const tool of diff.functionalityDelta.fixedTools) {
        lines.push(`- ✅ **Fixed:** ${tool} now working`);
      }
    }

    if (diff.functionalityDelta.newBrokenTools.length > 0) {
      for (const tool of diff.functionalityDelta.newBrokenTools) {
        lines.push(`- ❌ **Broken:** ${tool} no longer working`);
      }
    }
    lines.push("");
  }

  // Module Status Changes
  const changedModules = diff.moduleChanges.filter(
    (m) => m.change !== "unchanged",
  );
  if (changedModules.length > 0) {
    lines.push("## Module Changes");
    lines.push("");
    lines.push("| Module | Baseline | Current | Change |");
    lines.push("|--------|----------|---------|--------|");

    for (const mod of changedModules) {
      const scoreInfo = formatScoreChange(mod.baselineScore, mod.currentScore);
      lines.push(
        `| ${formatModuleName(mod.module)} | ${mod.baselineStatus}${scoreInfo.baseline} | ${mod.currentStatus}${scoreInfo.current} | ${formatChangeIcon(mod.change)} ${scoreInfo.change} |`,
      );
    }
    lines.push("");
  }

  // Recommendations
  if (diff.recommendations.length > 0) {
    lines.push("## Recommendations");
    lines.push("");
    for (const rec of diff.recommendations) {
      if (rec.startsWith("  -")) {
        lines.push(rec);
      } else {
        lines.push(`### ${rec}`);
      }
    }
    lines.push("");
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(
    `*Generated by MCP Inspector Assessment v${diff.current.assessorVersion}*`,
  );

  return lines.join("\n");
}

/**
 * Format a date string
 */
function formatDate(dateStr: string): string {
  try {
    const date = new Date(dateStr);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  } catch {
    return dateStr;
  }
}

/**
 * Format change direction with icon
 */
function formatChangeIcon(change: ChangeDirection): string {
  switch (change) {
    case "improved":
      return "⬆";
    case "regressed":
      return "⬇";
    case "unchanged":
      return "➡";
  }
}

/**
 * Format status change
 */
function formatStatusChange(baseline: string, current: string): string {
  if (baseline === current) return "➡ No change";
  if (current === "PASS" && baseline !== "PASS") return "⬆ Improved";
  if (baseline === "PASS" && current !== "PASS") return "⬇ Regressed";
  return "↔ Changed";
}

/**
 * Format numeric change with +/-
 */
function formatNumericChange(diff: number): string {
  if (diff === 0) return "➡ 0";
  if (diff > 0) return `⬆ +${diff}`;
  return `⬇ ${diff}`;
}

/**
 * Format score change info
 */
function formatScoreChange(
  baseline?: number,
  current?: number,
): { baseline: string; current: string; change: string } {
  if (baseline === undefined || current === undefined) {
    return { baseline: "", current: "", change: "" };
  }

  const diff = current - baseline;
  const sign = diff > 0 ? "+" : "";

  return {
    baseline: ` (${baseline.toFixed(0)}%)`,
    current: ` (${current.toFixed(0)}%)`,
    change: `${sign}${diff.toFixed(0)}%`,
  };
}

/**
 * Format module name for display
 */
function formatModuleName(name: string): string {
  // Convert camelCase to Title Case
  return name
    .replace(/([A-Z])/g, " $1")
    .replace(/^./, (str) => str.toUpperCase())
    .trim();
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
